<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>IronClad Engine: ic::util::CParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IronClad.ico"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IronClad Engine
   &#160;<span id="projectnumber">0.1 pre-release</span>
   </div>
   <div id="projectbrief">A OpenGL-based 2D engine. Currently at 6720 lines of code.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceic.html">ic</a></li><li class="navelem"><a class="el" href="namespaceic_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classic_1_1util_1_1_c_parser.html">CParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">ic::util::CParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parses files based on key=value1,value2,...,valueN pairs.  
 <a href="classic_1_1util_1_1_c_parser.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="_parser_8hpp_source.html">Parser.hpp</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfa2dae10f10bc390d15616ce246b094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#adfa2dae10f10bc390d15616ce246b094">LoadFromStream</a> (std::ifstream &amp;file, const std::streampos &amp;start=0, const std::streampos &amp;finish=-1, const char *filename=&quot;file&quot;)</td></tr>
<tr class="memdesc:adfa2dae10f10bc390d15616ce246b094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the key-value dictionary by parsing a file stream.  <a href="#adfa2dae10f10bc390d15616ce246b094"></a><br/></td></tr>
<tr class="memitem:a6c089c4129b6382981cec0e62be63102"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c089c4129b6382981cec0e62be63102"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LoadFromStream</b> (const char **str, const uint32_t start, const uint32_t finish)</td></tr>
<tr class="memitem:ad9cab983e05253ecc32342975bb472a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9cab983e05253ecc32342975bb472a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LoadFromFile</b> (const std::string &amp;filename)</td></tr>
<tr class="memitem:a53c5ed0409dfb2988970b3f1d2667b01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c5ed0409dfb2988970b3f1d2667b01"></a>
KeyValueDict::const_iterator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a53c5ed0409dfb2988970b3f1d2667b01">Begin</a> () const </td></tr>
<tr class="memdesc:a53c5ed0409dfb2988970b3f1d2667b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at the beginning of the dictionary. <br/></td></tr>
<tr class="memitem:a684b9f3ea55f5e27599ddcfa714d2f57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684b9f3ea55f5e27599ddcfa714d2f57"></a>
KeyValueDict::const_iterator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a684b9f3ea55f5e27599ddcfa714d2f57">End</a> () const </td></tr>
<tr class="memdesc:a684b9f3ea55f5e27599ddcfa714d2f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at the end of the dictionary. <br/></td></tr>
<tr class="memitem:a5aa6093d9c5d84d35455e26da22aea2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5aa6093d9c5d84d35455e26da22aea2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a5aa6093d9c5d84d35455e26da22aea2d">Reset</a> ()</td></tr>
<tr class="memdesc:a5aa6093d9c5d84d35455e26da22aea2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the dictionary. <br/></td></tr>
<tr class="memitem:a4e3ce77359ce3549fe6e67a70c0c386c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a4e3ce77359ce3549fe6e67a70c0c386c">GetValue</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a4e3ce77359ce3549fe6e67a70c0c386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a value based on a key in the dictionary.  <a href="#a4e3ce77359ce3549fe6e67a70c0c386c"></a><br/></td></tr>
<tr class="memitem:adb2bf1c37b9728d5e90e0bf089326d12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2bf1c37b9728d5e90e0bf089326d12"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetValue</b> (const std::string &amp;key) const </td></tr>
<tr class="memitem:a5b97c27fdb4621bfc68341afc45e2cc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b97c27fdb4621bfc68341afc45e2cc6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a5b97c27fdb4621bfc68341afc45e2cc6">GetValuei</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a5b97c27fdb4621bfc68341afc45e2cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return a converted representation of a value. <br/></td></tr>
<tr class="memitem:ad9fafbdf61c26a5193815cdad1e899e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fafbdf61c26a5193815cdad1e899e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetValueb</b> (const std::string &amp;key) const </td></tr>
<tr class="memitem:aac7f162f9a1c103fb0958e4ca2a55f40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac7f162f9a1c103fb0958e4ca2a55f40"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>GetValuef</b> (const std::string &amp;key) const </td></tr>
<tr class="memitem:a358be5fb6d675b5cdadacf9c4d60d3ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a358be5fb6d675b5cdadacf9c4d60d3ed">GetValues</a> (const std::string &amp;key, const char delimiter) const </td></tr>
<tr class="memdesc:a358be5fb6d675b5cdadacf9c4d60d3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of values from a key-value pair based on a char.  <a href="#a358be5fb6d675b5cdadacf9c4d60d3ed"></a><br/></td></tr>
<tr class="memitem:a798489c8d1edd145677c05b34c52af7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798489c8d1edd145677c05b34c52af7e"></a>
KeyValueDict &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a798489c8d1edd145677c05b34c52af7e">GetPairs</a> ()</td></tr>
<tr class="memdesc:a798489c8d1edd145677c05b34c52af7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the dictionary. <br/></td></tr>
<tr class="memitem:ad706d414fcf56dcbe39f959efe189de1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad706d414fcf56dcbe39f959efe189de1"></a>
const KeyValueDict &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetPairs</b> () const </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2105b9b958e37b871cfa362b586e90ff"><td class="memItemLeft" align="right" valign="top">static std::streampos&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classic_1_1util_1_1_c_parser.html#a2105b9b958e37b871cfa362b586e90ff">FindInFile</a> (std::ifstream &amp;stream, const char *pfinder, const std::streampos &amp;max_pos=-1)</td></tr>
<tr class="memdesc:a2105b9b958e37b871cfa362b586e90ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first instance of a string within a file stream.  <a href="#a2105b9b958e37b871cfa362b586e90ff"></a><br/></td></tr>
<tr class="memitem:a9b21da176387abf95270dfb29429f15c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b21da176387abf95270dfb29429f15c"></a>
static std::streampos&#160;</td><td class="memItemRight" valign="bottom"><b>FindInFile</b> (std::ifstream &amp;stream, const std::string &amp;finder, const std::streampos &amp;max_pos=-1)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file parses defines a very generic type of parsing, since most files (meshes, levels) in IronClad use a similar formatting. For example, an ICLevel, a entity can be placed like so: &lt;entity&gt; &lt;surface&gt; texture=Quad.tga position=100,200 w=32 h=32</p>
<p>texcoords=0,0,1,0,1,1,0,1 &lt;/surface&gt; &lt;/entity&gt;</p>
<p>So, you can see that values are split up by an '=' delimiter. Thus, this generic parser can create a dictionary of values that can then be easily accessed. This eliminates the need to read the file sequential and worry about what might come later and what options are defined while you're reading. Now, you can read in the file (or portion of a file), and then access the values by key, given that they exist. </p>

<p>Definition at line <a class="el" href="_parser_8hpp_source.html#l00122">122</a> of file <a class="el" href="_parser_8hpp_source.html">Parser.hpp</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2105b9b958e37b871cfa362b586e90ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::streampos ic::util::CParser::FindInFile </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pfinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streampos &amp;&#160;</td>
          <td class="paramname"><em>max_pos</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function basically reads a file until it finds an instance of "pfinder" in the current line, up until it reaches the optional "max_pos" argument, which specifies a position in the stream to stop at. If left at the default, -1, the search is done till EOF (or some other reason causing std::getline to return false). The function will return the stream to its starting point as it was when the function was called.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::ifstream&amp;</td><td>Stream to search </td></tr>
    <tr><td class="paramname">char*</td><td>String to find </td></tr>
    <tr><td class="paramname">std::streampos</td><td>Place to stop search (optional=EOF)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Position the requested string was found at, std::streampos(-1) if it was not found.</dd></dl>
<p>Stream is left at the same point it started at. </p>

</div>
</div>
<a class="anchor" id="a4e3ce77359ce3549fe6e67a70c0c386c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CParser::GetValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the file stream contained 'texture=Data.tga', and you called GetValue("texture"), the function gives back "Data.tga".</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>Key to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Value if it exists, empty string otherwise.</dd></dl>
<p>The returned value (in non-const) is safe to modify, since it is a copy of the value. The original is impossible to change, regardless. </p>

<p>Definition at line <a class="el" href="_parser_8cpp_source.html#l00126">126</a> of file <a class="el" href="_parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a358be5fb6d675b5cdadacf9c4d60d3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; CParser::GetValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will split the 'value' part of a pair based on a delimiter, and return the result.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>Key to access </td></tr>
    <tr><td class="paramname">char</td><td>Character to split 'value' on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Result if 'key' exists, the 'value' in the pair (in a vector) if not.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespaceic_1_1util.html#a80c5e53506e6351b14e2ab5dc08342fe" title="Splits a string into individual parts at an special character.">util::split()</a> </dd></dl>

<p>Definition at line <a class="el" href="_parser_8cpp_source.html#l00153">153</a> of file <a class="el" href="_parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfa2dae10f10bc390d15616ce246b094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ic::util::CParser::LoadFromStream </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streampos &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streampos &amp;&#160;</td>
          <td class="paramname"><em>finish</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;file&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is more versatile than the generic LoadFromFile(), since you can specify where in the stream you would like to start and where you would like to end. By default, the whole file is read. This comes in handy if a file, for example, has several entity specifications, so there's more than one "texture" key. Thus you could read until "&lt;entity&gt;", mark that, read till "&lt;/entity&gt;", mark that, then pass the stream to this method and it would only give you the key-value pairs found in that section of the file.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::ifstream</td><td>File stream to read </td></tr>
    <tr><td class="paramname">std::streampos</td><td>Starting point in the stream (opt=0) </td></tr>
    <tr><td class="paramname">std::streampos</td><td>Ending point in the stream (opt=END) </td></tr>
    <tr><td class="paramname">char*</td><td>Filename the stream comes from (opt="file")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>TRUE if at least one pair was parsed, FALSE otherwise, or if file was not open. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>IronClad/include/IronClad/Utils/<a class="el" href="_parser_8hpp_source.html">Parser.hpp</a></li>
<li>IronClad/src/Utils/<a class="el" href="_parser_8cpp_source.html">Parser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 12 2013 13:27:33 for IronClad Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
